#!/usr/bin/env python3

# Copyright (c) Akatsumekusa and contributors

# ---------------------------------------------------------------------
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Hi, wanderer! If you wants to use this DependencyControl generator
# for your own repository, please ping Akatsumekusa and let them help
# you set up. However, if that's not possible for whatever reason, here
# is a small explanation on how this generator works.
# 
# There are two main ways one can modify a branch, merge to it or
# directly commit to it.
# For merges, GitHub Actions or local post-merge hook will trigger the
# generator. It will diff HEAD to HEAD^, and if there are changes to
# macros and modules, it will bump the version number inside the Lua
# files, update the DependencyControl.json and then make a new commit
# to HEAD.
# For commits directly to the branch, local pre-commit hook will
# trigger the generator. It will diff cached to HEAD, and if there are
# changes to macros and modules, it will bump the version number inside
# the Lua files, update the DependencyControl.json and then add the
# changes to the commit. Note that if you have unstaged changes inside
# the Lua files, please stash them with `git stash --keep-index` before
# committing.
# 
# However, how can the generator be able to recognise macro and module
# version in the first place? Well, it uses a pretty stupid method.
# Every macros and modules in the repository must has a versioning
# table in their register file. If you look into init.lua of all the
# Akatsumekusa's modules, you will see an example of how it is done.
# 
# One thing that isn't automated is the required modules. When you
# added a dependency to a macro or module, you not only need to
# write it into the register function of DependencyControl, you also
# have to log it here in the dictionary below.
# 
# Oh I haven't mentioned you have to modify the DependencyControl
# dictionary below. It is the exact same object as
# DependencyControl.json. You can learn its structure at
# https://github.com/TypesettingTools/DependencyControl . When you
# are filling your own information into the dictionary below, if you
# see items that are commented out, those items are going to be
# automatically generated by the script and you don't need to fill them
# in.
# 
# When you have done all of that, here is a final checklist for you
# to make sure that everything is set before making the first commit:
# - [ ] Have you backup your local repostiory?
# - [ ] Is the hooks and GitHub Actions set up?
# - [ ] Is table versioning added to the register script of whichever
#       macros or modules you are going to add to DependencyControl?
# - [ ] Have you log your own information and repository URL to the
#       dictionary below?
# - [ ] Have you add all the macros and modules you want to add to
#       DependencyControl to the dictionary below?
# - [ ] Have you set the branch in the branch string below and have you
#       set your macros and modules in the dictionary with the right
#       channel / branch?
# - [ ] Have you add the required modules of your macros and modules to
#       the dictionary below?
# And then you can create an empty DependencyControl.json in the root
# folder of your repository and try your first commit.
# ---------------------------------------------------------------------

from datetime import datetime, timezone
from git import Repo
import hashlib
import importlib.util
import json
from pathlib import Path, PurePosixPath
import re
from semantic_version import Version
import sys

repo = Repo(".")
branch = "dev" # Generator is only active in the set branch
default = True
DependencyControl = {
    "dependencyControlFeedFormatVersion": "0.3.0",

    "name": "Akatsumekusa's Aegisub Scripts",
    "description": "Repository for Akatsumekusa's Aegisub Scripts",
    "maintainer": "Akatsumekusa",
    "baseUrl": "https://github.com/Akatmks/Akatsumekusa-Aegisub-Scripts",
    "url": "@{baseUrl}",
    "fileBaseUrl": "raw.githubusercontent.com/Akatmks/Akatsumekusa-Aegisub-Scripts/@{channel}",

    "macros": {},
    "modules": {}
        # namespace: {
        #     author
        #     name
        #     description
        #     url
        #     "channels": {
        #         branch: {
        #             version
        #             released
        #             default
        #             "files": [], # name url sha1
        #             "requireModules": [] # moduleName
        #         }
        #     }
        # }
}
excluded_files = [
    "modules/aka/luajit-request/LICENSE.md"
]

previousDependencyControl = None

getSearchPattern = {
    #                               ([^\.]\s*versioning\s*(?:\.|=\s*{[^}]*?|=\s*{(?:[^}]*?{(?:[^}]*?{(?:[^}]*?{[^}]*?})*?[^}]*?})*?[^}]*?})*?[^}]*?)\s*version\s*=\s*[\"\'])(.*?[^\\]|)([\"\'])
    ".lua": lambda key: key.join((r"([^\.]\s*versioning\s*(?:\.|=\s*{[^}]*?|=\s*{(?:[^}]*?{(?:[^}]*?{(?:[^}]*?{[^}]*?})*?[^}]*?})*?[^}]*?})*?[^}]*?)\s*", r"\s*=\s*[\"\'])(.*?[^\\]|)([\"\'])")),
    #                                ([^\.]\s*versioning\s*(?:\.\s*version\s*=|=[^=]*?version\s*:)\s*[\"\'])(.*?[^\\]|)([\"\'])
    ".moon": lambda key: key.join((r"([^\.]\s*versioning\s*(?:\.\s*", r"\s*=|=[^=]*?", r"\s*:)\s*[\"\'])(.*?[^\\]|)([\"\'])"))
}

def search(p):
    d = {}
    
    if p.suffix not in getSearchPattern:
        return None

    with p.open("r", encoding="utf-8") as f:
        s = f.read()
        
    for key in ["name", "description", "version", "author", "namespace", "requireModules"]:
        match = re.search(getSearchPattern[p.suffix](key), s)
        if match:
            d[key] = re.sub("\\\\([\"\'])", "\\1", match.group(2))
        else:
            if key == "requireModules":
                d[key] = None
            else:
                return None

    return d

def sha1sum(p):
    with p.open("rb") as f:
        return hashlib.sha1(f.read()).hexdigest()

def getNamespace(p):
    return ".".join((p.parts[1], p.parts[2])) if len(p.parts) > 3 else \
           ".".join((p.parts[1], p.stem)) if len(p.parts) == 3 else \
           p.stem

def writeVersion(p, version):
    with p.open("r", encoding="utf-8") as f:
        s = f.read()

    s = re.sub(getSearchPattern[p.suffix]("version"),
               lambda match: match.group(1) + str(version) + match.group(3),
               s)
    
    with p.open("w", encoding="utf-8") as f:
        f.write(s)

    repo.index.add(str(p))

def getNameForFilesFile(p):
    parts = p.parts
    if len(p.parts) == 2 or len(p.parts) == 3:
        return p.suffix
    elif len(p.parts) > 3:
        return PurePosixPath("/", *p.parts[3:]).as_posix()
    else:
        raise ValueError(str(p))

if __name__ == "__main__":
    if not repo.active_branch.name == branch:
        sys.exit()

    p = Path("DependencyControl.json")
    if not p.exists():
        sys.exit()
    with p.open("r", encoding="utf-8") as f:
        try:
            previousDependencyControl = json.load(f)
        except:
            previousDependencyControl = None

    moduleRegisterPathList = {}
    for entry in repo.index.entries:
        p = Path(entry[0])

        if p.is_relative_to("macros"):
            mtype = "macros"
        elif p.is_relative_to("modules"):
            mtype = "modules"
        else:
            continue
        if p.as_posix() in excluded_files:
            continue
        
        # Create the file in the list
        namespace = getNamespace(p)

        if namespace not in DependencyControl[mtype]:
            DependencyControl[mtype][namespace] = {}
        if "channels" not in DependencyControl[mtype][namespace]:
            DependencyControl[mtype][namespace]["channels"] = {}
        if branch not in DependencyControl[mtype][namespace]["channels"]:
            DependencyControl[mtype][namespace]["channels"][branch] = {}
        if "files" not in DependencyControl[mtype][namespace]["channels"][branch]:
            DependencyControl[mtype][namespace]["channels"][branch]["files"] = []
        DependencyControl[mtype][namespace]["channels"][branch]["files"].append({
            "name": getNameForFilesFile(p),
            "url": PurePosixPath("@{fileBaseUrl}", p).as_posix(),
            "sha1": sha1sum(p)
        })

        # Check if the file is the registering file
        d = search(p)

        if d:
            if namespace != d["namespace"]:
                raise ValueError(str(p))
            
            DependencyControl[mtype][namespace]["author"] = d["author"]
            DependencyControl[mtype][namespace]["name"] = d["name"]
            DependencyControl[mtype][namespace]["description"] = d["description"]
            DependencyControl[mtype][namespace]["url"] = "@{baseUrl}"

            DependencyControl[mtype][namespace]["channels"][branch]["version"] = d["version"]
            DependencyControl[mtype][namespace]["channels"][branch]["default"] = default
            if d["requireModules"]:
                DependencyControl[mtype][namespace]["channels"][branch]["requireModules"] = eval(d["requireModules"])
            if previousDependencyControl and \
               namespace in previousDependencyControl[mtype] and \
               "channels" in previousDependencyControl[mtype][namespace] and \
               branch in DependencyControl[mtype][namespace]["channels"]:
                previousVersion = Version(previousDependencyControl[mtype][namespace]["channels"][branch]["version"])
                currentVersion = Version(d["version"])
                if previousVersion == currentVersion:
                    DependencyControl[mtype][namespace]["channels"][branch]["released"] = previousDependencyControl[mtype][namespace]["channels"][branch]["released"]
                elif previousVersion < currentVersion:
                    DependencyControl[mtype][namespace]["channels"][branch]["released"] = datetime.now(timezone.utc).date().isoformat()
                else:
                    raise ValueError(str(p))
            else:
                DependencyControl[mtype][namespace]["channels"][branch]["released"] = datetime.now(timezone.utc).date().isoformat()

            moduleRegisterPathList[namespace] = p

    added = []
    removed = []
    changed = []
    diff_indexes = repo.head.commit.diff()
    if not diff_indexes:
        diff_indexes = repo.head.commit.diff("HEAD^")
    for diff_index in diff_indexes:
        match diff_index.change_type: # match requires Python 3.10
            case "A":
                added.append(Path(diff_index.b_path))
            case "D":
                removed.append(Path(diff_index.a_path))
            case "R":
                added.append(Path(diff_index.b_path))
                removed.append(Path(diff_index.a_path))
            case "M" | "T":
                changed.append(Path(diff_index.a_path))
            case _:
                raise ValueError(str(diff_index))

    changedModules = {}
    for p in added + changed:
        if p.is_relative_to("macros"):
            namespace = getNamespace(p)
            currentVersion = Version(DependencyControl["macros"][namespace]["channels"][branch]["version"])
            currentVersion.patch += 1
            writeVersion(p, currentVersion)
            DependencyControl["macros"][namespace]["channels"][branch]["files"][0]["sha1"] = sha1sum(p)

            DependencyControl["macros"][namespace]["channels"][branch]["version"] = str(currentVersion)
            DependencyControl["macros"][namespace]["channels"][branch]["released"] = datetime.now(timezone.utc).date().isoformat()
        if p.is_relative_to("modules"):
            namespace = getNamespace(p)
            if namespace not in changedModules:
                changedModules[namespace] = True

                currentVersion = Version(DependencyControl["modules"][namespace]["channels"][branch]["version"])
                currentVersion.patch += 1
                writeVersion(moduleRegisterPathList[namespace], currentVersion)
                for file in DependencyControl["modules"][namespace]["channels"][branch]["files"]:
                    if file["name"] == getNameForFilesFile(moduleRegisterPathList[namespace]):
                        file["sha1"] = sha1sum(moduleRegisterPathList[namespace])

                DependencyControl["modules"][namespace]["channels"][branch]["version"] = str(currentVersion)
                DependencyControl["modules"][namespace]["channels"][branch]["released"] = datetime.now(timezone.utc).date().isoformat()
    for p in removed:
        if p.is_relative_to("macros"):
            pass
        if p.is_relative_to("modules"):
            namespace = getNamespace(p)
            if namespace in moduleRegisterPathList and namespace not in changedModules:
                changedModules[namespace] = True

                currentVersion = Version(DependencyControl["modules"][namespace]["channels"][branch]["version"])
                currentVersion.patch += 1
                writeVersion(moduleRegisterPathList[namespace], currentVersion)
                for file in DependencyControl["modules"][namespace]["channels"][branch]["files"]:
                    if file["name"] == getNameForFilesFile(moduleRegisterPathList[namespace]):
                        file["sha1"] = sha1sum(moduleRegisterPathList[namespace])

                DependencyControl["modules"][namespace]["channels"][branch]["version"] = str(currentVersion)
                DependencyControl["modules"][namespace]["channels"][branch]["released"] = datetime.now(timezone.utc).date().isoformat()

    p = Path("DependencyControl.json")
    with p.open("w", encoding="utf-8") as f:
        json.dump(DependencyControl, f, indent=4)
    repo.index.add(str(p))
