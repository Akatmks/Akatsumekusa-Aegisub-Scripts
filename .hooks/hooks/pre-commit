#!/usr/bin/env python3
# Copyright (c) Akatsumekusa and contributors

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from datetime import datetime, timezone
from git import Repo
import hashlib
import importlib.util
import json
from pathlib import Path, PurePosixPath
import re
from semantic_version import Version
import sys

repo = Repo(".")

DependencyControl = {
    "dependencyControlFeedFormatVersion": "0.3.0",

    "name": "Akatsumekusa's Aegisub Scripts",
    "description": "Repository for Akatsumekusa's Aegisub Scripts",
    "maintainer": "Akatsumekusa",
    "baseUrl": "https://github.com/Akatmks/Akatsumekusa-Aegisub-Scripts",
    "url": "@{baseUrl}",
    "fileBaseUrl": "raw.githubusercontent.com/Akatmks/Akatsumekusa-Aegisub-Scripts/@{channel}",

    "macros": {},
    "modules": {
        "aka.config": {
            "url": "@{baseUrl}",
            # author
            # name
            # description
            "channels": {
                "dev": {
                    # version
                    # released
                    "default": True,
                    "files": [], # name url sha1
                    "requireModules": [
                        { "moduleName": "aka.config2" },
                        { "moduleName": "aka.template", "optional": True }
                    ]
                }
            }
        },
        "aka.config2": {
            "url": "@{baseUrl}",
            # author
            # name
            # description
            "channels": {
                "dev": {
                    # version
                    # released
                    "default": True,
                    "files": [], # name url sha1
                    "requireModules": [
                        { "moduleName": "aegisub.re" },
                        { "moduleName": "aegisub.unicode" },
                        { "moduleName": "lfs" }
                    ]
                }
            }
        },
        "aka.template": {
            "url": "@{baseUrl}",
            # author
            # name
            # description
            "channels": {
                "dev": {
                    # version
                    # released
                    "default": True,
                    "files": [], # name url sha1
                    "requireModules": [
                        { "moduleName": "aka.config2" }
                    ]
                }
            }
        }
    }
}

previousDependencyControl = None

def search(p):
    d = {}
    #              ([^\.]\s*versioning\s*\.\s*version\s*=\s*["'])(.*?[^\\]|)(["'])
    expression = ["([^\\.]\\s*versioning\\s*\\.\\s*", "\\s*=\\s*[\"\'])(.*?[^\\\\]|)([\"\'])"]

    with p.open("r", encoding="utf-8") as f:
        s = f.read()
        
    for key in ["name", "description", "version", "author", "namespace"]:
        match = re.search(expression[0] + key + expression[1], s)
        if not match:
            return None
        d[key] = match.group(2)

    return d

def sha1sum(p):
    with p.open("rb") as f:
        return hashlib.sha1(f.read()).hexdigest()

def getNamespace(p):
    return ".".join((p.parts[1], p.parts[2])) if len(p.parts) > 3 else \
           ".".join((p.parts[1], p.stem)) if len(p.parts) == 3 else \
           p.stem

def writeVersion(p, version):
    with p.open("r", encoding="utf-8") as f:
        s = f.read()

    #           ([^\.]\s*versioning\s*\.\s*version\s*=\s*["'])(.*?[^\\]|)(["'])
    s = re.sub("([^\\.]\\s*versioning\\s*\\.\\s*version\\s*=\\s*[\"\'])(.*?[^\\\\]|)([\"\'])",
               lambda match: match.group(1) + str(version) + match.group(3),
               s)
    
    with p.open("w", encoding="utf-8") as f:
        f.write(s)

    repo.index.add(str(p))

if __name__ == "__main__":
    p = Path("DependencyControl.json")
    if not p.exists():
        sys.exit()
    with p.open("r", encoding="utf-8") as f:
        try:
            previousDependencyControl = json.load(f)
        except:
            previousDependencyControl = None

    moduleRegisterPathList = {}
    for entry in repo.index.entries:
        p = Path(entry[0])

        if p.is_relative_to("macros"):
            namespace = getNamespace(p)
            d = search(p)

            if d:
                if namespace != d["namespace"]:
                    raise ValueError(str(p))
                
                DependencyControl["macros"][namespace]["author"] = d["author"]
                DependencyControl["macros"][namespace]["name"] = d["name"]
                DependencyControl["macros"][namespace]["description"] = d["description"]

                if previousDependencyControl and namespace in previousDependencyControl["macros"]:
                    previousVersion = Version(previousDependencyControl["macros"][namespace]["channels"]["dev"]["version"])
                    currentVersion = Version(d["version"])
                    if previousVersion == currentVersion:
                        DependencyControl["macros"][namespace]["channels"]["dev"]["version"] = d["version"]
                        DependencyControl["macros"][namespace]["channels"]["dev"]["released"] = previousDependencyControl["macros"][namespace]["channels"]["dev"]["released"]
                    elif previousVersion < currentVersion:
                        DependencyControl["macros"][namespace]["channels"]["dev"]["version"] = d["version"]
                        DependencyControl["macros"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()
                    else:
                        raise ValueError(str(p))
                else:
                    DependencyControl["macros"][namespace]["channels"]["dev"]["version"] = d["version"]
                    DependencyControl["macros"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()

                DependencyControl["macros"][namespace]["channels"]["dev"]["files"].append({
                    "name": "." + p.suffix,
                    "url": PurePosixPath("@{fileBaseUrl}", p).as_posix(),
                    "sha1": sha1sum(p)
                })
            else:
                raise ValueError(str(p))
        if p.is_relative_to("modules"):
            namespace = getNamespace(p)
            d = search(p)

            if d:
                if namespace != d["namespace"]:
                    raise ValueError(str(p))

                DependencyControl["modules"][namespace]["author"] = d["author"]
                DependencyControl["modules"][namespace]["name"] = d["name"]
                DependencyControl["modules"][namespace]["description"] = d["description"]

                if previousDependencyControl and namespace in previousDependencyControl["modules"]:
                    previousVersion = Version(previousDependencyControl["modules"][namespace]["channels"]["dev"]["version"])
                    currentVersion = Version(d["version"])
                    if previousVersion == currentVersion:
                        DependencyControl["modules"][namespace]["channels"]["dev"]["version"] = d["version"]
                        DependencyControl["modules"][namespace]["channels"]["dev"]["released"] = previousDependencyControl["modules"][namespace]["channels"]["dev"]["released"]
                    elif previousVersion < currentVersion:
                        DependencyControl["modules"][namespace]["channels"]["dev"]["version"] = d["version"]
                        DependencyControl["modules"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()
                    else:
                        raise ValueError(str(p))
                else:
                    DependencyControl["modules"][namespace]["channels"]["dev"]["version"] = d["version"]
                    DependencyControl["modules"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()
                
                moduleRegisterPathList[namespace] = p
            
            DependencyControl["modules"][namespace]["channels"]["dev"]["files"].append({
                "name": p.suffix if len(p.parts) == 2 or len(p.parts) == 3 else \
                        PurePosixPath("/", *p.parts[3:len(p.parts)]).as_posix(),
                "url": PurePosixPath("@{fileBaseUrl}", p).as_posix(),
                "sha1": sha1sum(p)
            })

    added = []
    removed = []
    changed = []
    for diff_index in repo.head.commit.diff():
        match diff_index.change_type:
            case "A":
                added.append(Path(diff_index.b_path))
            case "D":
                removed.append(Path(diff_index.a_path))
            case "R":
                added.append(Path(diff_index.b_path))
                removed.append(Path(diff_index.a_path))
            case "M" | "T":
                changed.append(Path(diff_index.a_path))
            case _:
                raise ValueError(str(diff_index))

    changedModules = {}
    for p in added + changed:
        if p.is_relative_to("macros"):
            namespace = getNamespace(p)
            currentVersion = Version(DependencyControl["macros"][namespace]["channels"]["dev"]["version"])
            currentVersion.patch += 1
            writeVersion(p, currentVersion)
            DependencyControl["macros"][namespace]["channels"]["dev"]["files"][0]["sha1"] = sha1sum(p)

            DependencyControl["macros"][namespace]["channels"]["dev"]["version"] = str(currentVersion)
            DependencyControl["macros"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()
        if p.is_relative_to("modules"):
            namespace = getNamespace(p)
            if namespace not in changedModules:
                changedModules[namespace] = True
                currentVersion = Version(DependencyControl["modules"][namespace]["channels"]["dev"]["version"])
                currentVersion.patch += 1
                writeVersion(moduleRegisterPathList[namespace], currentVersion)
                DependencyControl["modules"][namespace]["channels"]["dev"]["version"] = str(currentVersion)
                DependencyControl["modules"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()
    for p in removed:
        if p.is_relative_to("macros"):
            pass
        if p.is_relative_to("modules"):
            namespace = getNamespace(p)
            if namespace in moduleRegisterPathList and namespace not in changedModules:
                changedModules[namespace] = True
                currentVersion = Version(DependencyControl["modules"][namespace]["channels"]["dev"]["version"])
                currentVersion.patch += 1
                writeVersion(moduleRegisterPathList[namespace], currentVersion)
                for file in DependencyControl["macros"][namespace]["channels"]["dev"]["files"]:
                    if file.name == p.suffix if len(p.parts) == 2 or len(p.parts) == 3 else \
                                    PurePosixPath("/", *p.parts[3:len(p.parts)]).as_posix():
                        file["sha1"] = sha1sum(p)

                DependencyControl["modules"][namespace]["channels"]["dev"]["version"] = str(currentVersion)
                DependencyControl["modules"][namespace]["channels"]["dev"]["released"] = datetime.now(timezone.utc).date().isoformat()

    p = Path("DependencyControl.json")
    with p.open("w", encoding="utf-8") as f:
        json.dump(DependencyControl, f, indent=4)
    repo.index.add(str(p))
